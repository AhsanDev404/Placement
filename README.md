# Placement preparation by AhsanDev404


# Programming Fundamentals Q&A

## Compile-time vs Runtime
**Q:** What is the difference between compile-time and runtime?

**A:** Compile-time refers to code conversion into an executable form, while runtime is when the program is executed.

## Compiler vs Interpreter
**Q:** What is the difference between a compiler and an interpreter?

**A:** A compiler translates the entire source code into machine code, whereas an interpreter translates and executes code line by line.

## Variables vs Constants
**Q:** What is the difference between a variable and a constant?

**A:** A variable is a storage location holding a value, while a constant remains unchanged during program execution.

## Assignment Operators in Programming
**Q:** What is the difference between =, ==, and === in programming languages?

**A:** = assigns a value, == compares values for equality, and === compares both values and data types.

## Loops and Control Statements
**Q:** What is the difference between a while loop and a do-while loop?

**A:** A while loop checks the condition first; if false, the loop doesn't execute. A do-while loop always executes at least once.

**Q:** What is the purpose of the break statement in a loop?

**A:** The break statement exits a loop prematurely, regardless of the loop condition.

**Q:** What is the purpose of the continue statement in a loop?

**A:** The continue statement skips the current iteration and moves to the next one.

## Variables Scope and Functions
**Q:** What is the difference between a local variable and a global variable?

**A:** A local variable is scoped within a function, while a global variable is accessible throughout the program.

**Q:** What is the purpose of the return statement in a function?

**A:** The return statement exits a function and optionally returns a value to the caller.

## Function Parameters and Data Structures
**Q:** What is the difference between pass by value and pass by reference?

**A:** Pass by value copies the argument, while pass by reference passes the memory address of the argument.

**Q:** What is the purpose of an array in programming?

**A:** An array stores multiple values of the same data type in contiguous memory locations.

## Strings, Characters, and Conditional Statements
**Q:** What is the difference between a string and a character?

**A:** A character is a single alphanumeric/special character, while a string is a sequence of characters.

**Q:** What is the purpose of conditional statements in programming?

**A:** Conditional statements execute different code blocks based on a specified condition.

## Operators and Preprocessor Directives
**Q:** What is the purpose of the modulus operator (%) in programming?

**A:** The modulus operator returns the remainder of a division operation.

**Q:** What is a function and why is it used in programming?

**A:** A function is a reusable block of code that performs a specific task, promoting reusability and improving readability.

**Q:** What is recursion in programming?

**A:** Recursion is a technique where a function calls itself to solve a problem, breaking it into smaller subproblems.

## Memory Management and File Structure
**Q:** What is the difference between a stack and a heap?

**A:** A stack is used for static memory allocation, storing local variables and function call information. A heap is used for dynamic memory allocation, storing objects and data structures.

**Q:** What is the difference between a header file and a source file?

**A:** A header file contains declarations and function prototypes, while a source file contains the actual implementation of functions.

**Q:** What is the purpose of a preprocessor directive in programming?

**A:** Preprocessor directives provide instructions to the compiler before compilation, used for including header files, macro definitions, conditional compilation, etc.

# Object Oriented Programming Q&A

## What is Object-Oriented Programming?
**Q:** What is Object-Oriented Programming?

**A:** Object-Oriented Programming is a paradigm organizing code into objects with properties and behaviors, emphasizing encapsulation, inheritance, polymorphism, and abstraction.

## Four Fundamental Principles of OOP
**Q:** What are the four fundamental principles of OOP?

**A:** The four fundamental principles of OOP are encapsulation, inheritance, polymorphism, and abstraction.

## Encapsulation in OOP
**Q:** What is encapsulation in OOP?

**A:** Encapsulation bundles data and methods into an object, providing data hiding and internal state protection.

## Inheritance in OOP
**Q:** What is inheritance in OOP?

**A:** Inheritance allows a class to inherit properties and behaviors from another class, promoting code reuse and hierarchy creation.

## Polymorphism in OOP
**Q:** What is polymorphism in OOP?

**A:** Polymorphism enables an object to take multiple forms, treating different class objects as a common superclass, achieved through method overriding and method overloading.

## Method Overriding in OOP
**Q:** What is method overriding in OOP?

**A:** Method overriding lets a subclass provide a different implementation of a method defined in its superclass, enabling runtime polymorphism.

## Method Overloading in OOP
**Q:** What is method overloading in OOP?

**A:** Method overloading allows a class to have multiple methods with the same name but different parameters, determined by passed arguments, enabling compile-time polymorphism.

## Abstraction vs Encapsulation
**Q:** What is the difference between abstraction and encapsulation?

**A:** Abstraction hides unnecessary details and provides a simplified interface, while encapsulation bundles data and methods, protecting the internal state of an object.

## Class vs Object
**Q:** What is the difference between a class and an object?

**A:** A class is a blueprint or template for creating objects, defining their properties and behaviors, while an object is an instance of a class.

## Purpose of 'this' Keyword in OOP
**Q:** What is the purpose of the 'this' keyword in OOP?

**A:** 'this' refers to the current object within a class, used to differentiate instance variables and local variables, invoke constructors, and pass the current object as an argument to other methods.

## Composition vs Inheritance
**Q:** What is the difference between composition and inheritance?

**A:** Composition involves a class being composed of objects of other classes as members, while inheritance allows a class to inherit properties and behaviors from another class.

## Abstract Class in OOP
**Q:** What is an abstract class in OOP?

**A:** An abstract class cannot be instantiated, serves as a blueprint, and can have both defined and undefined (abstract) methods, guiding concrete subclasses.

## Interface in OOP
**Q:** What is an interface in OOP?

**A:** An interface defines a contract with abstract methods for classes to implement, specifying required methods without providing implementations.

## Abstract Class vs Interface
**Q:** What is the difference between an abstract class and an interface?

**A:** An abstract class can have both defined and undefined methods, while an interface only has undefined methods. A class can implement multiple interfaces but inherit from only one class.

## Method Overloading vs Method Overriding
**Q:** What is the difference between method overloading and method overriding?

**A:** Method overloading occurs with multiple methods of the same name but different parameters in a class. Method overriding occurs when a subclass provides a different implementation of a method defined in its superclass.

# Data Structures and Algorithms Q&A

## What is a data structure?
**Q:** What is a data structure?

**A:** A data structure organizes and stores data efficiently, defining the relationship between data and operations that can be performed on it.

## Array vs Linked List
**Q:** What is the difference between an array and a linked list?

**A:** An array is a sequential collection of elements, while a linked list consists of nodes, each containing a value and a reference to the next node.

## Time Complexity of Array Operations
**Q:** What is the time complexity of inserting an element in an array?

**A:** O(n) - Insertion may require shifting subsequent elements.

**Q:** What is the time complexity of accessing an element in an array?

**A:** O(1) - Direct access by index.

## Stack Implementation and Operations
**Q:** What is a stack and how is it implemented?

**A:** A stack follows the Last-In-First-Out (LIFO) principle and can be implemented using an array or a linked list.

**Q:** What is the time complexity of push and pop operations in a stack?

**A:** O(1) - Both push and pop operations are constant time operations.

## Queue Implementation and Operations
**Q:** What is a queue and how is it implemented?

**A:** A queue follows the First-In-First-Out (FIFO) principle and can be implemented using an array or a linked list.

**Q:** What is the time complexity of enqueue and dequeue operations in a queue?

**A:** O(1) - Both enqueue and dequeue operations are constant time operations.

## Binary Tree and Types
**Q:** What is a binary tree and its types?

**A:** A binary tree has at most two children per node. Types include full, complete, balanced, and binary search trees.

## Searching in Binary Search Tree
**Q:** What is the time complexity of searching in a binary search tree?

**A:** O(log n) on average, O(n) in the worst case for unbalanced trees.

## BFS vs DFS
**Q:** What is the difference between breadth-first search (BFS) and depth-first search (DFS)?

**A:** BFS explores vertices level by level, while DFS explores as deep as possible before backtracking.

## Time Complexity of Sorting Algorithms
**Q:** What is the time complexity of bubble sort, insertion sort, and selection sort?

**A:** O(n^2) in the worst case for all three, considered inefficient for large datasets.

**Q:** What is the time complexity of the merge sort algorithm?

**A:** O(n log n) - Merge sort uses the divide-and-conquer approach.

## Linked List vs Array
**Q:** What is the difference between a linked list and an array?

**A:** Linked list is dynamic with pointers, while an array is static with contiguous memory. Arrays allow random access; linked lists require sequential traversal.

## Hash Table vs Hash Set
**Q:** What is the difference between a hash table and a hash set?

**A:** Hash table stores key-value pairs, supporting efficient lookup, insert, and delete. Hash set stores unique values, offering similar operations.

# Database Q&A

## What is a database?
**Q:** What is a database?

**A:** A database is a structured collection of data organized and stored for efficient retrieval, manipulation, and management.

## Database Management System (DBMS)
**Q:** What is a DBMS?

**A:** A Database Management System (DBMS) is software that provides an interface to interact with the database, enabling storage, retrieval, updating, and management of data.

## Primary Key vs Foreign Key
**Q:** What is the difference between a primary key and a foreign key?

**A:** A primary key is a unique identifier for a record, while a foreign key in a table refers to the primary key in another table, establishing a relationship between them.

## Normalization in Databases
**Q:** What is normalization in the context of databases?

**A:** Normalization is organizing data to reduce redundancy and enhance data integrity by dividing a database into multiple tables and defining relationships.

## ACID Properties in Database Transactions
**Q:** What are the ACID properties in database transactions?

**A:** ACID stands for Atomicity, Consistency, Isolation, and Durability, ensuring transactions are treated as indivisible units, maintain consistency, isolate concurrent transactions, and guarantee permanence.

## SQL Joins
**Q:** What is a join in SQL?

**A:** A join in SQL combines rows from multiple tables based on related columns, enabling data retrieval from multiple tables simultaneously.

**Q:** What are the different types of joins in SQL?

**A:** Inner join, left join, right join, and full outer join specify different rules for combining rows from tables.

## Database Indexing
**Q:** What is indexing in a database?

**A:** Indexing creates data structures to speed up data retrieval operations like searching, sorting, and filtering by improving efficiency.

## Database Transactions
**Q:** What is a transaction in a database?

**A:** A transaction represents a single unit of work involving multiple database operations, ensuring atomicity, consistency, isolation, and durability.

## Clustered vs Non-Clustered Index
**Q:** What is the difference between a clustered and non-clustered index?

**A:** A clustered index determines the physical order of data, while a non-clustered index is a separate structure containing indexed columns and pointers to actual data.

## Database vs Data Warehouse
**Q:** What is the difference between a database and a data warehouse?

**A:** A database is structured for efficient storage, retrieval, and management, while a data warehouse is a large repository of transformed data for analysis and reporting.

## SQL Injection Attack Prevention
**Q:** What is a SQL injection attack and how can it be prevented?

**A:** SQL injection is a security vulnerability where attackers insert malicious SQL statements. Prevention methods include parameterized queries, input validation, and access control.

## Database Views
**Q:** What is a view in a database?

**A:** A view is a virtual table based on a query's result, acting as a predefined query, facilitating easier data access and manipulation.

## DELETE vs TRUNCATE in SQL
**Q:** What is the difference between DELETE and TRUNCATE in SQL?

**A:** DELETE removes specific rows using Data Manipulation Language (DML), while TRUNCATE, a Data Definition Language (DDL) command, removes all rows, effectively resetting the table.

## Unique Key vs Primary Key
**Q:** What is the difference between a unique key and a primary key?

**A:** A unique key ensures uniqueness and allows null values, while a primary key uniquely identifies each row without allowing null values.

# Analytical Reasoning Q&A

## The Two Egg Problem
**Q:** What is the minimum number of egg drops required to find the highest floor from which an egg can be dropped without breaking?

**A:** The optimal solution involves using a binary search approach, requiring a minimum of 7 egg drops.

## The Monty Hall Problem
**Q:** Should you switch or stick with your initial choice in the Monty Hall Problem to maximize your chances of winning the car?

**A:** It is more beneficial to switch doors, as it increases the probability to 2/3 of winning the car.

## The Birthday Problem
**Q:** In a room of N people, what is the probability that at least two people have the same birthday?

**A:** The probability can be calculated using the formula: 1 - (365!/((365-N)! * 365^N)).

## The Bridge Crossing Problem
**Q:** What is the minimum time required for all four people to cross the bridge considering their varying crossing times?

**A:** The optimal solution involves having the two fastest people cross together, followed by the two slowest people, requiring the sum of the two fastest people's times plus the time taken by the two slowest people.

## The Coin Change Problem
**Q:** Given a set of coins of different denominations and a target amount, how can you find the minimum number of coins needed to make the target amount?

**A:** This problem can be solved using dynamic programming, calculating the minimum number of coins needed for each target amount up to the desired target.

## The Traveling Salesman Problem
**Q:** What is the shortest possible route that visits each city exactly once and returns to the starting city in the Traveling Salesman Problem?

**A:** The Traveling Salesman Problem is commonly solved using algorithms like the Held-Karp algorithm or the Lin-Kernighan heuristic, providing approximate solutions.

## The Three Jugs Problem
**Q:** How can you measure exactly 4 liters of water using 3 jugs with capacities of 3, 5, and 8 liters?

**A:** A series of pouring and emptying steps can be performed to achieve exactly 4 liters in the 5-liter jug.

## The Prisoner Hat Problem
**Q:** What strategy should the prisoners use to maximize their chances of being set free in the Prisoner Hat Problem?

**A:** The prisoners can use a strategy based on counting the number of black hats in front of each prisoner to determine their own hat color, ensuring at least 99 prisoners guess correctly.

## The Two-Sum Problem
**Q:** How can you find two numbers in an array that add up to a target sum?

**A:** This problem can be solved using a two-pointer approach, sorting the array and moving pointers towards each other while comparing the sum of the pointed elements with the target sum.

## The Hat Puzzle
**Q:** Which lockers will be open after all 100 students pass in the Hat Puzzle?

**A:** The lockers with indices corresponding to perfect square numbers will be open, such as lockers 1, 4, 9, 16, and so on.

# Topics

## Array
- **Introduction:** An array is a collection of elements stored in contiguous memory locations, accessible using an index or key.
- **Declaration and Initialization:** Arrays are declared with a specific data type and can be initialized with predefined values or dynamically populated.
- **Accessing Array Elements:** Elements in an array are accessed using their index, starting from 0.
- **Array Operations:** Arrays support operations like insertion, deletion, and finding the length.

## Linked List
- **Introduction:** A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node in the list.
- **Types:** Linked lists can be singly linked (each node points to the next node) or doubly linked (each node points to both the next and previous nodes).
- **Operations:** Linked lists support operations like insertion, deletion, and traversal.

## Stack
- **Introduction:** A stack is an abstract data type that follows the Last-In-First-Out (LIFO) principle, where the last element added is the first one to be removed.
- **Operations:** Stacks support push (adding an element) and pop (removing an element) operations.

## Queue
- **Introduction:** A queue is an abstract data type that follows the First-In-First-Out (FIFO) principle, where the first element added is the first one to be removed.
- **Operations:** Queues support enqueue (adding an element) and dequeue (removing an element) operations.

## Tree
- **Introduction:** A tree is a hierarchical data structure with a root node and child nodes, forming a branching structure.
- **Types:** Trees can be binary trees (each node has at most two children) or n-ary trees (each node can have multiple children).
- **Common Tree Traversals:** In-order, pre-order, and post-order traversals are techniques to visit nodes in a tree.

## Graph
- **Introduction:** A graph is a collection of nodes connected by edges, representing relationships between the nodes.
- **Types:** Graphs can be directed (edges have a direction) or undirected (edges have no direction).
- **Traversal Algorithms:** Depth-First Search (DFS) and Breadth-First Search (BFS) are common graph traversal algorithms.

## Sorting Algorithms
- **Introduction:** Sorting algorithms arrange elements in a specific order (e.g., ascending or descending).
- **Common Sorting Algorithms:** Bubble Sort, Insertion Sort, Selection Sort, Merge Sort, and Quick Sort are widely used sorting algorithms.

## Searching Algorithms
- **Introduction:** Searching algorithms find the location of a specific element in a collection of data.
- **Common Searching Algorithms:** Linear Search and Binary Search are frequently used searching algorithms.

## Time and Space Complexity
- **Time Complexity:** Time complexity measures the amount of time an algorithm takes to run as a function of the input size.
- **Space Complexity:** Space complexity measures the amount of memory space an algorithm uses as a function of the input size.

## Recursion
- **Introduction:** Recursion is a programming technique where a function calls itself to solve a smaller instance of the problem.
- **Base Case:** A recursive function must have a base case to stop the recursion and prevent infinite loops.

## Big O Notation
- **Introduction:** Big O notation describes the upper bound of an algorithm's growth rate, indicating how the algorithm's time or space complexity scales with the input size.
- **Notation Types:** O(1) (constant time), O(log n) (logarithmic time), O(n) (linear time), O(n log n) (linearithmic time), O(n^2) (quadratic time), etc.

## Dynamic Programming
- **Introduction:** Dynamic programming is a method for solving complex problems by breaking them down into simpler overlapping subproblems.
- **Memoization:** Memoization is a technique to optimize recursive algorithms by caching the results of subproblem solutions.

## Greedy Algorithms
- **Introduction:** Greedy algorithms make locally optimal choices at each step with the hope of finding a global optimum.
- **Examples:** Huffman Coding, Dijkstra's Algorithm, and Prim's Algorithm are examples of greedy algorithms.

## Divide and Conquer
- **Introduction:** Divide and conquer is a problem-solving strategy where a problem is divided into smaller subproblems that are solved independently. The solutions are then combined to solve the original problem.
- **Example:** Merge Sort and Quick Sort use the divide and conquer approach to sort elements efficiently.

## Hashing
- **Introduction:** Hashing is a technique that maps data of arbitrary size to fixed-size values, typically for fast data retrieval.
- **Hash Functions:** Hash functions convert input data (keys) into fixed-size hashes, ensuring efficient storage and retrieval in hash tables.

## Heaps and Priority Queues
- **Introduction:** A heap is a specialized tree-based data structure that satisfies the heap property, allowing efficient extraction of the minimum (or maximum) element.
- **Priority Queues:** Priority queues use heaps to maintain the order of elements based on their priorities.

## Graph Algorithms
- **Shortest Path:** Algorithms like Dijkstra's Algorithm and Bellman-Ford Algorithm find the shortest path between nodes in a graph.
- **Minimum Spanning Tree:** Algorithms like Prim's Algorithm and Kruskal's Algorithm find the minimum spanning tree of a graph, connecting all nodes with the minimum total edge weight.

# Problems

## Math Algorithms Problems

1. **FizzBuzz:**
   Write a program that prints the numbers from 1 to n. For multiples of three, print "Fizz" instead of the number, and for multiples of five, print "Buzz". For numbers that are multiples of both three and five, print "FizzBuzz".

2. **Fibonacci Sequence:**
   Write a function to generate the nth Fibonacci number. The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones (e.g., 0, 1, 1, 2, 3, 5, 8, 13, ...).

3. **Prime Numbers:**
   Write a program to determine whether a given number is prime or not.

4. **Factorial:**
   Write a function to calculate the factorial of a given number. The factorial of a non-negative integer n is the product of all positive integers less than or equal to n.

5. **Palindrome Number:**
   Write a program to determine whether a given number is a palindrome or not. A palindrome number reads the same backward as forward.

6. **Reverse Integer:**
   Write a function to reverse the digits of a given integer.

7. **GCD and LCM:**
   Write functions to find the greatest common divisor (GCD) and least common multiple (LCM) of two given numbers.

8. **Square Root:**
   Write a function to calculate the square root of a given positive number using Newton's method or any other suitable algorithm.

9. **Power of Two:**
   Write a program to determine whether a given number is a power of two or not.

10. **Sieve of Eratosthenes:**
    Implement the Sieve of Eratosthenes algorithm to find all prime numbers up to a given limit.

11. **Factorization:**
    Write a program to find the prime factors of a given number.

12. **Trailing Zeroes in Factorial:**
    Write a function to count the number of trailing zeroes in the factorial of a given number.

13. **Armstrong Number:**
    Write a program to determine whether a given number is an Armstrong number or not. An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of digits.

14. **HCF and LCM:**
    Write functions to find the highest common factor (HCF) and lowest common multiple (LCM) of two given numbers.

15. **Sum of Digits:**
    Write a function to calculate the sum of the digits of a given number.

Certainly! Here are 10 problems for each of the mentioned topics:

## Array Problems

1. **Find Maximum Element:**
   Given an array, find the maximum element in it.

2. **Array Rotation:**
   Rotate an array to the right by a given number of steps.

3. **Sum of Two Elements:**
   Given an array of integers, find two elements such that they add up to a specific target number.

4. **Remove Duplicates:**
   Remove duplicates from a sorted array and return the new length.

5. **Missing Number:**
   Find the missing number in an array containing n distinct numbers from 0 to n.

6. **Product of Array Except Self:**
   Given an array, compute an array where each element is the product of all elements in the original array except the current one.

7. **Subarray with Given Sum:**
   Find a subarray with a given sum in an array of positive integers.

8. **Max Consecutive Ones:**
   Given a binary array, find the maximum number of consecutive 1s.

9. **Merge Sorted Arrays:**
   Given two sorted arrays, merge them into a single sorted array.

10. **Pascal's Triangle:**
    Generate the first n rows of Pascal's triangle.

## Linked List Problems

1. **Reverse Linked List:**
   Reverse a singly linked list.

2. **Detect Cycle:**
   Detect if a linked list has a cycle.

3. **Find Middle Element:**
   Find the middle element of a linked list.

4. **Remove Nth Node From End:**
   Remove the nth node from the end of a linked list and return its head.

5. **Intersection Point:**
   Find the node at which the intersection of two singly linked lists begins.

6. **Palindrome Linked List:**
   Check if a linked list is a palindrome.

7. **Merge Two Sorted Lists:**
   Merge two sorted linked lists into a new sorted list.

8. **Add Two Numbers:**
   Given two non-empty linked lists representing two non-negative integers, add the numbers and return the sum as a linked list.

9. **Flatten a Multilevel Doubly Linked List:**
   Flatten a multilevel doubly linked list into a single-level doubly linked list.

10. **Copy Random Pointer:**
    A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list or null. Create a deep copy of the list.

## Stack Problems

1. **Valid Parentheses:**
   Given a string containing just the characters '(', ')', '{', '}', '[', and ']', determine if the input string is valid.

2. **Evaluate Reverse Polish Notation:**
   Evaluate the value of an arithmetic expression in Reverse Polish Notation.

3. **Min Stack:**
   Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

4. **Implement Queue using Stacks:**
   Implement a queue using two stacks.

5. **Next Greater Element:**
   Given an array, find the next greater element for every element.

6. **Expression Evaluation:**
   Evaluate a given expression in the form of a string.

7. **Implement Stack using Queues:**
   Implement a stack using queues.

8. **Largest Rectangle in Histogram:**
   Given an array of heights representing a histogram, find the area of the largest rectangle.

9. **Simplify Path:**
   Given an absolute path for a file, simplify it.

10. **Valid Parenthesis String:**
    Given a string containing only three types of characters: '(', ')', and '*', check whether this string is valid.

## Queue Problems

1. **Circular Queue Implementation:**
   Implement a circular queue with operations: enqueue, dequeue, isEmpty, and isFull.

2. **Sliding Window Maximum:**
   Given an array and an integer k, find the maximum for each and every contiguous subarray of size k.

3. **Design Twitter:**
   Design a simplified version of Twitter, where users can post tweets, follow/unfollow other users, and see the recent 10 tweets in the user's news feed.

4. **Rotting Oranges:**
   Given a grid representing a field with oranges, determine how many minutes pass until no cell has a fresh orange left.

5. **Implement Queue using Stacks:**
   Implement a queue using two stacks.

6. **Generate Binary Numbers:**
   Given a number n, generate the first n binary numbers.

7. **Implement Stack using Queues:**
   Implement a stack using queues.

8. **Queue Reconstruction by Height:**
   Reconstruct a queue based on height and the number of people in front.

9. **Moving Average from Data Stream:**
   Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.

10. **Implement Stack using Linked List:**
    Implement a stack using a linked list.

Certainly! Here are 10 problems for each of the mentioned topics:

## Tree Problems

1. **Binary Tree Maximum Path Sum:**
   Given a binary tree, find the maximum path sum. The path may start and end at any node in the tree.

2. **Lowest Common Ancestor:**
   Find the lowest common ancestor (LCA) of two nodes in a binary tree.

3. **Binary Tree Level Order Traversal:**
   Perform a level order traversal of a binary tree, i.e., traverse the tree level by level.

4. **Serialize and Deserialize Binary Tree:**
   Design an algorithm to serialize and deserialize a binary tree. Serialization is the process of converting a tree to a string, and deserialization is the process of reconstructing the tree from the string.

5. **Count Complete Tree Nodes:**
   Given a complete binary tree, count the number of nodes.

6. **Symmetric Tree:**
   Determine if a binary tree is symmetric (mirror image of itself).

7. **Convert Sorted Array to Binary Search Tree:**
   Given a sorted array, convert it into a height-balanced binary search tree (BST).

8. **Maximum Depth of Binary Tree:**
   Find the maximum depth of a binary tree, i.e., the length of the longest path from the root node to any leaf node.

9. **Path Sum:**
   Determine if a binary tree has a root-to-leaf path such that adding up all the numbers along the path equals a given sum.

10. **Balanced Binary Tree:**
    Determine if a binary tree is height-balanced, meaning the left and right subtrees' heights differ by at most one.

## Graph Problems

1. **Clone Graph:**
   Given a reference of a node in a connected undirected graph, return a deep copy of the graph.

2. **Word Ladder:**
   Given two words and a dictionary of words, find the length of the shortest transformation sequence from the first word to the second word, such that changing one letter at a time forms a valid word.

3. **Number of Islands:**
   Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.

4. **Graph Valid Tree:**
   Given n nodes labeled from 0 to n-1 and a list of undirected edges, check if the graph forms a valid tree.

5. **Course Schedule:**
   There are a total of n courses labeled from 0 to n-1. Some courses may have prerequisites. Determine if it is possible to finish all courses.

6. **Word Search:**
   Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.

7. **Alien Dictionary:**
   Given a list of words sorted in lexicographical order, construct the dictionary's order and return it. If the input is invalid, return an empty string.

8. **Graph Connectivity with Threshold:**
   Given an integer threshold and a 2D array of integers, determine if there exists a path between any two nodes such that the absolute difference between the values of nodes on the path is less than or equal to the threshold.

9. **Network Delay Time:**
   There are n network nodes, labeled from 1 to n, and times, a list of travel times as directed edges. Calculate the time it takes for all the nodes to receive the signal from node k. If the signal cannot reach all the nodes, return -1.

10. **Longest Increasing Path in a Matrix:**
    Given an m x n integers matrix, find the length of the longest increasing path.

## Sorting Algorithms Problems

1. **Kth Largest Element in an Array:**
   Find the kth largest element in an unsorted array.

2. **Top K Frequent Elements:**
   Given a non-empty array of integers, return the k most frequent elements.

3. **Sort Colors:**
   Given an array with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

4. **Meeting Rooms:**
   Given an array of meeting time intervals, determine if a person could attend all meetings.

5. **Merge Intervals:**
   Given a collection of intervals, merge overlapping intervals.

6. **Largest Number:**
   Given a list of non-negative integers, arrange them in such a way that they form the largest number.

7. **Sort List:**
   Sort a linked list in O(n log n) time using constant space complexity.

8. **Insertion Sort List:**
   Sort a linked list using insertion sort.

9. **Wiggle Sort:**
   Given an unsorted array, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= nums[3]....

10. **Longest Consecutive Sequence:**
    Given an unsorted array of integers, find the length of the longest consecutive elements' sequence.

## Searching Algorithms Problems

1. **Search in Rotated Sorted Array:**
   Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. You are given a target value to search. If found in the array, return its index; otherwise, return -1.

2. **Peak Element:**
   Find a peak element in an array. An array element is a peak if it is NOT smaller than its neighbors.

3. **Search a 2D Matrix:**
   Write an efficient algorithm that searches for a target value in an m x n matrix.

4. **Search in a Sorted Array of Unknown Size:**
   Given an integer array sorted in ascending order, write a function to search the target in an array. If the target exists, return its index; otherwise, return -1.

5. **Find Minimum in Rotated Sorted Array:**
   Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Find the minimum element.

6. **First Bad Version:**
   You are a product manager, and your company is planning to release a new product. However, the development is ongoing, and some versions are bad. Find the first bad version.

7. **Intersection of Two Arrays:**
   Given two arrays, write a function to compute their intersection.

8. **Search a 2D Matrix II:**
   Write an efficient algorithm that searches for a target value in an m x n matrix. Integers in each row and column are sorted in ascending order.

9. **Find Peak Element:**
   A peak element in an array is an element which is greater than or equal to its neighbors. Find a peak element in an array.

10. **Minimum Number of Days to Make m Bouquets:**
    Given an integer array bloomDay, an integer m, and an integer k, you need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden. The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.

## Time and Space Complexity Problems

1. **Time Complexity Analysis:**
   Analyze the time complexity of an algorithm that traverses a given array of size n and performs constant-time operations on each element.

2. **Space Complexity Analysis:**
   Analyze the space complexity of an algorithm that generates all subsets of a given set of n elements using recursion.

3. **Linear Search Time Complexity:**
   Determine the time complexity of linear search in an array of size n elements.

4. **Binary Search Time Complexity:**
   Determine the time complexity of binary search in a sorted array of size n elements.

5. **Bubble Sort Time Complexity:**
   Analyze the time complexity of the bubble sort algorithm for sorting an array of n elements.

6. **Merge Sort Time Complexity:**
   Analyze the time complexity of the merge sort algorithm for sorting an array of n elements.

7. **Quick Sort Time Complexity:**
   Analyze the time complexity of the quick sort algorithm for sorting an array of n elements.

8. **Factorial Space Complexity:**
   Determine the space complexity of a recursive algorithm to calculate the factorial of a number n.

9. **Fibonacci Sequence Time Complexity:**
   Analyze the time complexity of a recursive algorithm to find the nth Fibonacci number using memoization.

10. **Recursive Power Function Space Complexity:**
    Determine the space complexity of a recursive function to calculate the power of a number x raised to the power of y.

## Recursion Problems

1. **Factorial using Recursion:**
   Write a recursive function to calculate the factorial of a non-negative integer n.

2. **Fibonacci Sequence using Recursion:**
   Write a recursive function to find the nth Fibonacci number.

3. **Sum of Digits using Recursion:**
   Write a recursive function to find the sum of digits of a positive integer.

4. **Binary Search using Recursion:**
   Implement binary search using recursion in a sorted array.

5. **Tower of Hanoi Problem:**
   Solve the Tower of Hanoi problem for n disks using recursion.

6. **Recursive Palindrome Check:**
   Write a recursive function to check if a given string is a palindrome.

7. **Recursive Factorial Sum:**
   Write a recursive function to find the sum of factorials of numbers from 1 to n.

8. **Recursive GCD (Greatest Common Divisor):**
   Write a recursive function to find the GCD of two non-negative integers.

9. **Recursive Combination Calculation:**
   Write a recursive function to calculate the combination (nCk) of two non-negative integers n and k.

10. **Recursive Fibonacci Sum:**
    Write a recursive function to find the sum of the first n Fibonacci numbers.

## Big O Notation Problems

1. **Constant Time Complexity:**
   Write an algorithm with constant time complexity O(1) that performs a specific task.

2. **Linear Time Complexity:**
   Write an algorithm with linear time complexity O(n) that finds the maximum element in an array of size n.

3. **Logarithmic Time Complexity:**
   Write an algorithm with logarithmic time complexity O(log n) that performs a binary search on a sorted array of size n.

4. **Linearithmic Time Complexity:**
   Write an algorithm with linearithmic time complexity O(n log n) that sorts an array of n elements using merge sort.

5. **Quadratic Time Complexity:**
   Write an algorithm with quadratic time complexity O(n^2) that performs bubble sort on an array of size n.

6. **Exponential Time Complexity:**
   Write an algorithm with exponential time complexity O(2^n) that generates all subsets of a set with n elements.

7. **Factorial Time Complexity:**
   Write an algorithm with factorial time complexity O(n!) that generates all permutations of a set with n elements.

8. **Polynomial Time Complexity:**
   Write an algorithm with polynomial time complexity O(n^k) that evaluates a polynomial of degree k for a given input n.

9. **Quasilinear Time Complexity:**
   Write an algorithm with quasilinear time complexity O(n log^2 n) that performs a modified version of merge sort.

10. **Cubic Time Complexity:**
    Write an algorithm with cubic time complexity O(n^3) that performs matrix multiplication of two n × n matrices.

## Dynamic Programming Problems

1. **Fibonacci Sequence using Dynamic Programming:**
   Implement a dynamic programming solution to find the nth Fibonacci number.

2. **Coin Change Problem:**
   Given a set of coins with different denominations and a target amount, find the minimum number of coins needed to make the target amount. You have an unlimited supply of each coin denomination.

3. **Longest Common Subsequence:**
   Given two strings, find the length of their longest common subsequence.

4. **Knapsack Problem:**
   Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack.

5. **Matrix Chain Multiplication:**
   Given a sequence of matrices, find the most efficient way to multiply these matrices together.

6. **Longest Increasing Subsequence:**
   Given an unsorted array of integers, find the length of the longest increasing subsequence.

7. **Edit Distance:**
   Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

8. **Rod Cutting Problem:**
   Given a rod of length n and a price list for different lengths, determine the maximum revenue that can be obtained by cutting and selling the rod.

9. **Palindrome Partitioning:**
   Given a string, partition it into palindromic substrings. Return all possible

 palindrome partitioning of the input string.

10. **Maximum Subarray Sum:**
    Given an array of integers, find the contiguous subarray with the largest sum.

## Greedy Algorithms Problems

1. **Activity Selection Problem:**
   Given a list of activities with start and finish times, select the maximum number of activities that don't overlap.

2. **Fractional Knapsack Problem:**
   Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value. You can break items for maximizing the total value.

3. **Huffman Coding:**
   Given a set of characters and their frequencies, construct a Huffman Tree to minimize the total encoding length.

4. **Job Sequencing with Deadlines:**
   Given a list of jobs with deadlines and profits, schedule the jobs to maximize the total profit. Each job takes one unit of time to complete.

5. **Dijkstra's Algorithm:**
   Given a graph with weighted edges, find the shortest path from a source node to all other nodes using Dijkstra's algorithm.

6. **Prim's Algorithm:**
   Given a connected, undirected graph with weighted edges, find a minimum spanning tree for the graph using Prim's algorithm.

7. **Kruskal's Algorithm:**
   Given a connected, undirected graph with weighted edges, find a minimum spanning tree for the graph using Kruskal's algorithm.

8. **Interval Scheduling Problem:**
   Given a list of intervals with start and finish times, find the maximum number of non-overlapping intervals.

9. **Water Supply Problem:**
   There are n cities connected by a network of pipes. Each pipe has a certain supply of water. Find the minimum supply of water needed at the source to supply all cities.

10. **Gas Station Problem:**
    There are n gas stations along a circular route. Each station has a certain amount of gas. Determine the starting gas station from where you can travel around the circle.

## Divide and Conquer Problems

1. **Binary Search using Divide and Conquer:**
   Implement binary search using the divide and conquer approach in a sorted array.

2. **Merge Sort:**
   Implement the merge sort algorithm to sort an array of n elements.

3. **Quick Sort:**
   Implement the quick sort algorithm to sort an array of n elements.

4. **Closest Pair of Points:**
   Given an array of n points in a plane, find the closest pair of points among them using the divide and conquer approach.

5. **Matrix Multiplication using Strassen's Algorithm:**
   Implement matrix multiplication for n × n matrices using Strassen's algorithm, a divide and conquer approach.

6. **Maximum Subarray Sum using Divide and Conquer:**
   Given an array of integers, find the contiguous subarray with the largest sum using the divide and conquer approach.

7. **Counting Inversions:**
   Given an array of n integers, count the number of inversions in the array using the divide and conquer approach.

8. **Convex Hull Problem:**
   Given a set of points in a plane, find the convex hull of the points using the divide and conquer approach.

9. **Largest Rectangular Area in a Histogram:**
   Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of the largest rectangle in the histogram.

10. **Closest Pair in 2D Plane:**
    Given a set of points in a 2D plane, find the closest pair of points among them using the divide and conquer approach.

## Hashing Problems

1. **Two Sum Problem:**
   Given an array of integers and a target sum, find two numbers in the array that add up to the target sum.

2. **Subarray Sum Equals K:**
   Given an array of integers, find the total number of continuous subarrays whose sum equals a specific target number K.

3. **Longest Subarray with Sum K:**
   Given an array of integers, find the length of the longest subarray with a sum equal to K.

4. **Four Sum Problem:**
   Given an array of integers and a target sum, find all unique quadruplets in the array that sum up to the target.

5. **Isomorphic Strings:**
   Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t.

6. **Valid Anagram:**
   Given two strings s and t, return true if t is an anagram of s, and false otherwise.

7. **Group Anagrams:**
   Given an array of strings, group the anagrams together.

8. **Longest Consecutive Sequence:**
   Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

9. **Minimum Window Substring:**
   Given a string S and a string T, find the minimum window in S that contains all the characters of T in complexity O(n).

10. **Longest Substring Without Repeating Characters:**
    Given a string, find the length of the longest substring without repeating characters.

## Heaps and Priority Queues Problems

1. **Kth Smallest Element in a Sorted Matrix:**
   Given a matrix where every row and column is sorted in ascending order, find the kth smallest element in the matrix.

2. **Merge K Sorted Lists:**
   Merge k sorted linked lists and return it as one sorted list.

3. **Sliding Window Maximum:**
   Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Return the maximum element inside the window at each distinct position of the moving window.

4. **Find Median from Data Stream:**
   Design a data structure that supports the following two operations: addNum(int num) - Add a unique number to the data structure, and findMedian() - Return the median of all elements so far.

5. **Top K Frequent Elements:**
   Given a non-empty array of integers, return the k most frequent elements.

6. **Frequency Sort:**
   Given a string, sort it based on the frequency of characters.

7. **Kth Largest Element in an Array:**
   Find the kth largest element in an unsorted array.

8. **Rearrange String k Distance Apart:**
   Given a non-empty string s and an integer k, rearrange the string such that the same characters are at least distance k from each other.

9. **Find K Pairs with Smallest Sums:**
   You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u, v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1, v1), (u2, v2) ..., (uk, vk) with the smallest sums.

10. **Find the Shortest Superstring:**
    Given an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is a substring of another string in A.

## Graph Algorithms Problems

1. **Course Schedule II:**
   There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites. The prerequisites of a course i are represented as a list of courses directly pointing to i. Return the ordering of courses you should take to finish all courses.

2. **Network Delay Time:**
   There are n network nodes, labeled from 1 to n, and times, a list of travel times as directed edges. Calculate the time it takes for all the nodes to receive the signal from node k. If the signal cannot reach all the nodes, return -1.

3. **Word Ladder II:**
   Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequences from beginWord to endWord, such that:
   1. Only one letter can be changed at a time.
   2. Each transformed word must exist in the word list.

4. **Alien Dictionary:**
   Given a list of words sorted in lexicographical order, construct the dictionary's order and return it. If the input is invalid, return an empty string.

5. **Word Search II:**
   Given a 2D board and a list of words from the dictionary, find all words in the board.

6. **Perfect Squares:**
   Given a positive integer n, find the least number of perfect square numbers which sum to n.

7. **Number of Islands II:**
   A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation.

8. **Bus Routes:**
   We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example, if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever.

9. **Longest Increasing Path in a Matrix:**
   Given an m x n integers matrix, find the length of the longest increasing path.

10. **Dungeon Game:**
    The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. When the princess enters a room, the demons immediately attack her. You need to find the knight's minimum initial health so that he can rescue the princess.
